# 이쯤에서 자바의 역사와 JVM에 대해서 알아보자

## 자바의 역사
> 자바는 "WORA(Write Once, Run Anywhere)" 모토로 만들어 졌다. 여러 플랫폼에서 실행할 수 있는 개발 언어를 목표로 개발되었다.  
> `Java SE 7`부터는 `Oracle`이라는 회사가 Sun Microsystems를 인수하여 지금에 이르고 있다.

### JDK 플랫폼에 따른 차이
- 자바는 Oracle에서만 만드는게 아니다.
- 각 Java 버전에서 제공되어야하는 표준 문서가 만들어지면 그 기준에 해당하는 각 벤더에 맞는 JDK가 별도로 만들어진다.
- 어떤 OS에서 개발하든 JDK의 버전만 맞으면 적용할 OS에서 컴파일만 하면 애플리케이션 실행에 문제가 없다.
    - Oracle JDK로 개발하고 HP의 JDK에서 컴파일 하더라도 실행에 문제가되지 않는다.

### JDK, J2SE, Java SE
- JDK : Java Development Kit
- J2SE : Java 2 Standard Edition
- Java SE : Java Standard Edition
    - 마케팅을 위해서 보다 자바를 쉽게 부를 수 있도록 J2SE에서 2를 제거

### JRE
- JRE : Java Runtime Environment
    - JRE는 실행만을 위한 환경이다. JRE만 설치하게 되면 자바를 컴파일하는 등의 각종 프로그램이 제외된 상태로 설치된다.
    - JRE는 자바를 실행할 수 있는 환경의 집합

### 자바언어의 특징
1. 자바는 "단순하고. 객체지향이며, 친숙"해야 한다.
2. 자바는 "견고하며, 보안상 안전"하다.
3. 자바는 "아키텍처에 중립적이어야 하며 포터블"해야 한다.
    4. 어떤 플랫폼에서도 동일한 결과가 나온다.
    4. 포터블한 환경을 제공하는 것은 JVM 덕이다.
4. 자바는 "높은 성능"을 제공해야 한다.
    5. 가비지 컬렉터는 낮은 우선 순위의 스레드로 동작하기 때문에 보다 높은 성능을 낼 수 있다.
    6. 백그리운드 스레드로 동작함
5. 자바는 "인터프린트 언어이며, 스레드를 제공하고, 동적인 언어"이다.


## JIT 컴파일러는 도대체 뭘까?
> JIT는 `Just-In-Time`의 약자이다. 조금 더 쉬운 말로 풀어보면 동적 변환이라고 보면 된다.  
> 명칭은 컴파일러지만 실행시에 적용되는 기술이다.

- JIT는 바이트코드를 기계어로 변환하고 필요한 코드의 정보는 캐시에 담아두었다가 재사용하게 된다.
- javac 명령어를 사용하여 컴파일 하는 단계에서 만들어지는 class 파일은 바이트코드일 뿐이다.
- `자바 소스코드 -> 자바 컴파일러 -> 컴파일된 바이트코트 -> JVM -> 기계코드 -> 하드웨어 및 OS`
    - JVM -> 기계코드로 변환되는 부분을 JIT에서 수행한다.

### 클라이언트 컴파일러, 서버 컴파일러
- 자바는 클라이언트 컴파일러와 서버 컴파일러가 나눠져있다.
- 클라이언트 컴파일러는 애플리케이션 시작 시간을 빠르게하고 적은 메모리를 점유하도록 하는 것이 목적이다.
- 서버 컴파일러는 코어가 많은 장비에서 애플리케이션을 돌리기 위해 만들어진 컴파일러이다. 애플리케이션 수행 속도에 초점이 맞춰져있다.
- 기본적으로 자바가 시작할 때 알아서 클라이언트 장비인지 서버 장비인지를 확인한다.

**확인 기준**
- 2개 이상의 물리적 프로세서
- 2GB 이상의 물리적 메모리
- `windows OS`에서는 클라이언트 컴파일러로 실행 된다.

## 자바의 GC는 어떻게 진행되나요?
> 자바의 heap 영역에는 `young영역`과 `old영역`이 존재한다. Young 영역은 Eden과 Survivor 영역으로 나뉜다.   
> 자바는 객체의 메모리를 해제하기 위해 `마이너 GC`,`메이저 GC`를 수행하게 된다. 둘 중 더 빠르게 수행되는 것은 `마이너 GC`이다.
> 마이너 GC가 더 빠르게 수행되는 이유는 일반적으로 더 작은 공간이 할당되고 객체를 처리하는 방식도 다르기 때문이다.

**마이너 GC**
1. 처음 생성된 객체는 Eden 영역에서 생성된다.
2. Eden 영역이 꽉 차면 살아있는 객체만 Survivor 영역으로 복사되고, 다시 Eden 영역을 채우게 된다.
3. Survivor 영역에 꽉 차게되면 또다른 Survivor 영역으로 객체가 복사된다. 이때, Eden 영역에 있는 객체들 중 살아있는 객체들도 다른 Survivor 영역으로 옮긴다.
    4. 즉 Survivor 영역의 둘 중 하나는 반드시 비어있어야 한다.

**메이저 GC**
1. Survivor 영역에서 오래 살아남은 객체는 Old 영역으로 이동한다.
2. 지속적으로 이동하다가 Old 영역이 꽉 차게 되면 GC가 발생한다.

**여러 종류의 GC**
- Serial GC
    - 클라이언트용 장비에 최적화된 GC. WAS에서 이 방식을 사용하는 것을 추천하지 않음
- Parallel Young Generation Collector
- Parallel Old Generation Collector
- Concurrent Mark & Sweep Collector (CMS)
- G1(Garbage First)

**여기서 소개한 GC 말고도 많은 GC가 존재한다.**