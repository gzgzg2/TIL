## 2강 DBMS와 버퍼

### 기억장치 계층도
<img width="661" alt="image" src="https://user-images.githubusercontent.com/56028408/186421332-ee354190-2ea3-4c84-97ec-3451c87ebf03.png">

- 1차 기억장치는 접근 속도가 2,3차 기억장치보다 우수한 대신 데이터를 영속적으로 저장할 수 없다.
- 2차 3차 기억장치는 저렴한 비용으로 많은 데이터를 영속적으로 저장할 수 있지만 접근 속도가 느리다. 
- 많은 데이터를 영속적으로 저장하려 하면 속도를 잃고 속도를 얻고자하면 영속적으로 저장하기 힘들다는 트레이드 오프가 발생

### DBMS와 기억장치의 관계

DBMS는 성능 향상을 목적으로 메모리에 자주 사용되는 데이터를 캐싱 하는데 이때 데이터를 저장하는 메모리를 `버퍼(buffer)` 또는 `캐시(cache)`라고 부른다.  
버퍼는 사용자와 저장소 사이에서 SQL 구문의 디스크 접근을 줄여주는 역할을 한다. 캐시 또한 마찬가지이다. 버퍼와 캐시 모두 물리적인 매체로 메모리를 사용하는 경우가 많기 때문에 하드디스크 위에 있는 데이터에 접근하는 것보다 훨신 빠른 속도를 보장한다.

이러한 고속 접근이 가능한 버퍼에 데이터를 `어떻게, 어느 정도의 기간동안` 올릴지 관리하는 것이 버퍼 매니저이다.

### 메모리에 있는 두개의 버퍼

**데이터 캐시**
- 자주 검색되는 데이터는 빠른 조회를 위해 `데이터 캐시`에 저장됨
- 검색하려는 데이터가 `데이터 캐시`에 존재하지 않으면 DISK 접근을 피하기 힘들어짐
- 데이터 갱신보다 검색이 많은 경우에는 로그 버퍼의 사이즈를 줄이고 데이터 캐시의 사이즈를 늘려주는 것도 튜닝의 방법이 될 수 있음
- 데이터 캐시도 결국 메모리에 저장하기 때문에 영속적으로 저장할 수 없음

**로그버퍼**
- 로그 버퍼를 사용하게 되면 데이터 갱신이 SQL의 실행 시점과 저장소에 반영되는 시점에 차이가 있는 비동기 처리로 이뤄짐
- 로그 버퍼는 COMMIT이 발생하기 전까지 로그버퍼에 데이터를 저장해두고 COMMIT이 발생하면 저장된 데이터를 디스크로 정보를 복사한다.
- 단점은 로그 버퍼에 저장된 데이터가 COMMIT 되기 전 하드웨어 전원이 꺼지면 데이터가 유실 될 수 있음
- 검색보다 데이터 갱신이 잦은 애플리케이션이라면 데이터 캐시를 줄이고 로그 버퍼의 크기를 늘려주는 튜닝을 고려해볼 수 있음


**피할 수 없는 트레이드 오프**
- 메모리는 결국 휘발성 저장장치이기 때문에 데이터를 영속적으로 저장할 수 없다.
- 데이터를 영속적으로 저장할 수 있는 HDD는 접근 속도가 느리다. 
- 로그 버퍼에 저장된 데이터가 DBMS가 다운될 때 사라지는 현상은 DBMS가 갱신을 비동기로 하는 이상 피할 수 없다.
- 장애가 발생하여도 정합성을 유지하기 위해 Commit을 상시화 하면 디스크 동기 접근이 일어나 지연이 발생할 가능성이 있다. 


### 추가적인 메모리 영역 '워킹 메모리'
- 워킹 메모리는 정렬 또는 해시 관련 처리에 사용되는 작업용 영역이다. 
- 워킹 메모리는 ORDER BY 구, 집합 연산, 윈도우 함수 등의 기능을 사용될 떄 실행된다.
- 해시는 주로 테이블 등의 결합에서 해시 결합이 사용되는 때 실행된다.
- 이 메모리 영역의 이름과 관리 방법은 DBMS 마다 다르다.
- 워킹 메모리 영역이 다루려는 데이터양보다 작아 부족해지는 경우 DISK를 사용하기 떄문에 성능에 문제가 생길 수 있다.
  - OS의 swap과 같은 것


## 실무에서 겪은 문제를 학습한 내용 기반으로 고민해본 경험
### 문제 상황
매일 특정 시간마다 슬로우 쿼리가 발생하였음. 해당 쿼리는 500만 건이 넘는 데이터를 조회하는 쿼리 

### 트러블슈팅 
- 쿼리의 실행계획을 살펴보니 테이블 full 스캔과 Using filesort 발견
- 워킹 메모리 영역이 부족할 경우 disk swap을 이용하여 정렬하는 것을 인지
  - 하지만 튜닝은 index 추가만으로 해결이 되었음 ! 읽기도 자주 있지만, 데이터 변경도 자주 있기 떄문에 지켜봐야함   
- 데이터 캐시에 자주 조회되는 데이터가 저장되지 않았을 경우에는 읽기 속도가 느려질 수 있음 !
  - 해당 문제는 조회 조건에 맞는 필드의 복합 인덱스를 추가하여 해결하였음 

### 실행계획을 읽으면서 쿼리 튜닝했던 경험으로 얻은 교훈?
- 실제 운영서버와 개발서버의 데이터를 모두 동일하게 맞췄음에도 불구하고 실행계획이 매번 달랐음
  - 카탈로그 갱신과 데이터 캐시에 캐싱된 데이터 문일까? 라는 고민이 생김
  - 앞으로 실행계획을 확인할 때는 두개의 테스트 DB로 실행계획을 확인해봐야겠음.. 그리고 확인을 방해하는 요소들을 전부 제거하고 테스트 해볼 것 같음 !!   
    - 캐시 옵션이나 기타 등등.. 

   



  
