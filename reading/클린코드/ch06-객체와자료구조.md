# 객체와 자료 구조

### 자료 추상화

목록 1
```java
public class Point {
    public double x;
    public double y;
}
```

- 구현을 외부에 노출

목록 2
```java
public interface Point {
    double getX();
    double getY();
    void setCartesian();
    double getY();
    double getTheta();
    void setPolar(double r, double theta);
}
```
- 구현을 완전히 감춤
- 클래스 메서드가 접근 정책을 강제함 
  - 예제에선 읽을 때는 개별적으로 읽고, 설정할 때는 두 값을 한꺼번에 설정해야 하는 규칙

**구현을 추상화로 감추기**
- 변수 사이에 함수라는 계층을 넣는다고 구현이 감춰지지 않는다. 구현을 감추려면 추상화가 필요하다.
  - 목록 1에서 get, set 메서드가 추가된다고 해도 내부 구현이 외부에 노출되는 것은 동일 함
- 추상 인터페이스를 제공하여 사용자가 구현을 모른 채 자료의 핵심을 고작할 수 있어야 진정한 의미의 클래스이다. 
- 자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이 좋다.


### 자료/객체 비대칭
- 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다.
- 자료구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.
- 절차적인 코드는 기존 자료구조를 변경하지 않으면서 새 함수를 추가하기 쉽다.
- 객체지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.

**절차지향 코드는 수직 확장처럼 다가오고 객체지향 코드는 수평적 확장처럼 다가온다.**

### 상황에 맞게
- 새로운 함수가 아니라 새로운 자료가 필요하다면 이떄는 객체지향적 코드가 적합하다. (동일한 역할을 가진 대상이 추가된다면)
- 새로운 자료 타입이 아니라 새로운 함수가 필요한 경우엔 절차적인 코드가 조금 더 적합하다. (역할에 새로운 책임이 부여된다면)
- 모든 것이 객체라는 생각은 미신이다.

### 디미터의 법칙
- 디미터의 법직이란 잘 알려직 휴리스틱으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙
- 객체는 조회 함수로 내부 구조를 공개하면 안된다.


**디미터의 법칙 요약**

디미터의 법칙은 "클래스 C의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다."
- 클래스 C
- f가 생성한 객체
- f 인수로 넘어온 객체
- C 인스턴스 변수에 저장된 객체

**디미터의 법칙을 위반하는 경우**

```java

public class C {
    private Uram uram;
    
    public void f(Param param) {
        String queryParam = param.getQuery(); // OK
        uram.sleep(); // OK 

        G g = new G();
        g.add(1); // OK 
        g.getY().printMessage("hi"); // NO !!! G가 아닌 Y의 메소드를 호출하고 있으므로 위반
    }
}

```

### 기차충돌

```java
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
```

위와 같은 코드를 `기차 충돌` 이라 부른다. 여러 객차가 한 줄로 이어진 기차처럼 보이기 때문이다.
일반적으로 조잡하다 여겨지는 방식이므로 피하는 편이 좋다. 그런데 여기서 `getScratchDir()`의 응답 값이
자료구조라면 디미터의 법칙이 적용되지 않는다. 객체라면 내부 구조를 숨겨야하므로 확실히 디미터 법척을 위반하지만, 
자료 구조라면 내부 구조를 호출하므로 디미터 법칙이 적용되지 않는다.


### Tell don't Ask

**예제 1**
```java
ctxt.getAbsolutePathOfScratchDirectoryOption();

ctx.getScratchDirectoryOption().getAbsolutePath();
```
- 첫번째 방법은 ctxt 객체에 공개해야하는 메서드가 너무 많아진다. 
- 두번째 방법은 getScratchDirectoryOption()가 자료구조를 반환한다고 가정한다.

두 방식 다 객체지향적인 코드와 거리가 먼 것 같다..

**예제 2**
```java
BufferdOutputStream bos = ctxt.createScratchFileStream(classFileName);
```

`예제 1`이 임시 디렉토리의 절대경로를 가져오는 기능이라 가정하면 `예제 2`처럼 변경할 수 있다. 
변경한 코드는 내부 구조를 드러내지 않고 모듈에서 해당 함수는 자신이 몰라야하는 여러 객체를 탐색할 필요가 없어졌다.

사용자가 임시 파일을 사용하기 위해 ctxt에게 임시 디렉토리의 경로를 묻지 않고 특정 작업에 대한 수행을 요청한 것이다.


### 활성 레코드
- 활성 레코드는 DTO의 특수한 형태. save나 find와 같은 탐색 함수를 제공함
- 활성 레코드는 데이터베이스 테이블이나 다른 소스에서 자료를 직접 반환한 결과
- 활성 레코드에 비지니스 규칙을 추가하고 객체 취급하는 개발자가 흔하다. 하지만 이는 바람직하지 않음
  - 활성 레코드는 자료구조로 취급 해야함

### 결론
객체는 동작을 공개하고 자료를 숨긴다. 그래서 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면,
기존 객체에 새 동작을 추가하기는 어렵다. 

자료구조는 별다른 동작없이 자료를 노출한다. 그래서 기존 자료구조에 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료구조를 추가하기는 어렵다.




