# 테스트
> 계속 변화하는 애플리케이션에 대응하는 첫번째 전략이 확장과 변화를 고려한 객체지향 설계와 그것을 효과적으로 담아낼 수 있는 IoC/DI 같은 기술이라면
> 
> 두번째 전략은 만들어진 코드를 확신할 수 있게 해주고 변화에 유연하게 대처할 수 있는 테스트 기술이다. 스프링으로 개발하면서 테스트를 만들지 않는다면 이는 스프링이 지는 가치의 절반을 포기하는 셈이다.
> 

### UserDaoTest 다시보기

### 테스트의 유용성
- 처음과 동일한 기능을 수행함을 보장해줄 수 있는 방법은 바로 `테스트`이다.
- 테스트란 결국 `내가 예상하고 의도했던 대로 코드가 정확히 동작하는지 검증`하기 위한 작업
- 테스트가 정확히 동작하지 않는다는 것은 코드나 설계에 결함이 있음을 알 수 있음. 즉 개발자는 테스트를 통해 코드의 결함을 제거할 수 있음

### 웹을 통한 DAO 테스트의 문제점
보통 웹 프로그램에서 DAO를 테스트하려면 웹 프로그램을 실행하기 위한 모든 계층의 코드를 전부 작성하고 
이를 서버에 배치한뒤 실행시켜서 직접 사용자가 사용하는 방식처럼 테스트 해야한다.

이러한 테스트는 비효율적이다. 첫번째 문제점은 DAO를 테스트하기 위한 부가작업이 너무 많다는 점이고 
두번째는 목적은 DAO 테스트지만 다른 계층에서 문제가 발생하면 그 문제를 찾아내야한다는 수고가 필요하다. 

목적은 DAO 테스트 였는데 다른 계층의 코드와 컴포넌트, 그리고 서버 설정 상태까지 모두 테스트에 영향을 줄 수 있기 때문에 
직접 웹 프로그램을 실행시켜서 테스트 하는 방법은 비효율적이다.


### 작은 단위의 테스트 
- 테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직함
- 테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 한다.
- 통제할 수 없는 외부의 리소스에 의존하는 테스트는 단위 테스트라고 보기 어려울 수 있음
- 외부 리소스에 의존하는 경우 통합 테스트나 인수 테스트를 이용하여 검증할 필요가 있음
- 많은 단위가 참여하는 테스트는 문제의 원인을 찾는게 어려울 수 있으니 단위 테스트로 먼저 검증을 하고 난 뒤에 단위를 묶어 테스트 하는 것이 바람직

### 지속적인 개선과 점직전인 개발을 위한 테스트
- 처음 만든 초난감 DAO 코드를 객체지향적 코드로 발전시키는 과정의 일등 공신은 테스트였음
- 테스트가 없었다면 다양한 방법을 동원해서 코드를 수정하고 설계를 개선해나가는 과정이 미덥지 않을 수 있고 마음이 불편해지면서 개선을 멈췄을 수도 있음
- 결론은 DAO 기능을 검증해주는 테스트가 있었기 때문에 점직적으로 코드를 개선할 수 있었던 것. 코드의 결함도 테스트를 통해 빠르게 알아낼 수 있었음
- 테스트를 이용하면 새로운 기능의 정상동작을 확인할 뿐만 아니라 기존에 만들어뒀던 코드가 새로운 기능을 위해 수정한 코드로 인해 영향을 받지 않는지 확인할 수 있음

### main()을 이용한 테스트의 문제점


**수동 확인 작업의 번거로움**

UserDaoTest는 수행하는 과정과 입력 데이터의 준비를 모두 자동으로 진행하지만 값이 올바른지는 출력된 데이터를 보고 개발자가 판단해야 한다.
즉 테스트 수행은 코드에 의해 자동적으로 진행되지만 결과를 확인하는 일은 사람의 책임이므로 완전히 자동으로 테스트되는 방법이라고 말할 수 없다.
이러한 방법은 검증할 단위가 적을때는 문제가 되지 않지만 테스트가 커질수록 불편하다. 또한 작은 차이는 발견하지 못하고 지나칠 수 있다.

**실행 작업의 번거로움**

간단히 실행 가능한 main() 메소드라고 해도 매번 실행하는 것은 번거로울 수 있다. 테스트할 클래스가 수백개가 되고 main() 메소드도 그만큼
만들어진다면 전체 기능을 테스트하기 위해 main() 메소드를 수백번 실행해야하는 수고가 필요하다. 그리고 결과를 확인하는 것도 사람의 몫이기 때문에
수백개의 실행결과를 보고 정상수행인지 직접 확인해야한다. 결론은 main() 메소드를 실행하는 방법보다 좀 더 편리하고 체계적으로 테스트를 실행하고 그 결과를 확인하는
방법이 필요하다.

## 테스트의 효율적인 수행과 결과 관리
main 메소드로는 편리한 수행과 편리한 결과 확인이 어렵다. 때문에 일정한 패턴을 가진 테스트를 만들 수 있고, 많은 테스트를 간단하게 실행시키고, 
테스트 결과를 간단하게 확인하고 실패한 곳을 빠르게 찾아갈 수 있는 기능을 갖춘 테스트 지원 도구와 그에 맞는 테스트 작성 방법이 필요하다.

### Junit 테스트로 전환
Junit은 프레임워크이다. 프레임워크의 기본 동작원리는 제어의 역전이다. 프레임워크는 개발자가 만든 클래스의 제어 권한을 넘겨받아서 주도적으로 애플리케이션 흐름을 제어한다. 
Junit도 개발자가 만든 클래스의 오브젝트를 생성하고 실행하는 일을 대신한다. 따라서 프레임워크에서 동작하는 코드는
main() 메소드도 필요없고 오브젝트를 만들어서 실행시키는 코드를 만들 필요도 없다.


### 테스트 메소드 전환

새로 만들 테스트 메소드는 Junit 프레임워크가 요구하는 두가지 조건을 따라야한다.

1. 메소드가 public으로 선언되어야 한다.
2. 테스트 메소드의 리턴값은 void여야 한다.
2. 메소드에 @Test라는 애노테이션을 붙여줘야 한다.

### 빌드 툴
개발자 개인별로 IDE에서 Junit 도구를 사용해 테스트를 실행하는 것이 가장 편리하지만 여러 개발자가 만든 테스트 코드를 통합해서 
테스트를 수행해야 할 때는 서버에서 모든 코드를 가져와 통합하고 빌드한 뒤애 테스트를 수행하는 것이 좋다. 이떄는 빌드 스크립트를 이용해 Junit 테스트를
실행하고 결과를 메일로 통보받는 방법을 사용하면 된다. 

**(개인적인 생각)** 위와같은 상황 뿐만 아니라 테스트가 너무 많아 실행시간이 오래 소요되는 경우도 빌드 스크립트를 이용하면 좋은 해결 방법이 될 수 있을 것 같다.

### 테스트 결과의 일관성
- 테스트의 결과가 외부 상태에 따라 성공하기도 실패하기도 한다는 것은 큰 문제이다. 테스트는 코드가 변경되지 않으면 항상 동일한 결과를 내야한다.
- 기존 UserDaoTest의 문제는 이전 테스트 때문에 DB에 등록된 중복 데이터가 있을 수 있다는 점이다.
- 가장 좋은 해결책은 addAndGet() 테스트를 마치고 나면 테스트를 위해 등록된 데이터를 삭제해서 테스트를 수행하기 이전 상태로 만들어주는 것이다.
- 이러한 방식을 사용하면 테스트를 여러번 반복해서 실행하더라도 항상 동일한 결과를 얻을 수 있다.

### 포괄적인 테스트
- 테스트를 만들지 않는 것도 위험한 일이지만 성의없이 테스트를 만드는 바람에 문제가 있는 코드인데도 테스트가 성공하게 만드는 것은 더 위험하다.
- 특히 한 가지 결과만 검증하고 마는 것은 상당히 위험하다. 이런 테스트는 마치 하루에 두 번은 정확히 맞는다는 시계와 같을 수 있다.
- 모든 코드의 수정 후에는 그 수정에 영향을 받을만한 테스트를 실행하는 것을 잊지 말아야한다. (사이드 이펙트 체크)


