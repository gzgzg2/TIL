## 3강 DBMS와 실행 계획

### 권한 이양의 죄악
- RDB는 How(절차)를 사용자가 아닌 시스템에게 이양하고 사용자에게는 What(무엇)만을 기술하는 것으로 축소하였음
- RDB가 권한을 이양 이유는 그렇게 하는 것이 비즈니스 전체의 생산성을 향상 시키기 떄문
  - 이 말은 어느정도 맞다고 할 수 있다. 그 근거는 RDB가 시스템 세계의 곳곳에 침투해 있기 때문
  - 그러나 여전히 사용자는 RDB 사용을 어려워함. 그리고 How를 의식하지 않고 사용하는 것 때문에 성능적인 문제를 겪음
  - 성능적인 문제를 해결하기 위해선 RDB가 숨기고 있는 내부 절차를 들여다 봐야함

### 데이터에 접근하는 방법은 어떻게 결정할까?

<img width="661" alt="image" src="../img/dbms-processing-flow.png">

RDB에서 데이터 접근 절차를 결정하는 모듈은 쿼리 평가 엔진이라고 부른다. 쿼리 평가 엔진은 사용자로부터 입력받은 SQL을 처음 읽어들이는 모듈이기도 하다.  
쿼리 평가 모듈은 추가로 파서 또는 옵티마이저와 같은 여러 개의 서브 모듈로 구성된다. 각각의 서브 모듈로 입력받은 SQL의 구문을 검사하고 저장된 데이터에 `효율적으로` 접근하기 위한 실행계획을 세운다.


**파서**

`1️⃣ 사용자가 입력한 SQL의 구문을 검사`하는 모듈. 사용자가 입력한 SQL이 올바르지 않으면 이후 처리 작업이 불필요하기 때문에 데이터 접근 최적화 작업을 진행하기전 구문을 분석한다.  
파서는 입력한 쿼리를 검증하는 것 뿐만 아니라 SQL 구문을 정형적인 형식으로 변환해주는 역할또한 담당한다.

**옵티마이저**

옵티마이저는 DBMS의 두뇌의 핵심 역할을 담당한다. 옵티마이저는 검증이 끝난 쿼리를 토대로 해당 쿼리의 실행 계획을 최적화 한다.

접근 최적화는 인덱스 유무, 데이터 분산 또는 편향 정도, DBMS 내부 매개변수 등의 조건을 고려해서 `2️⃣ 선택 가능한 많은 실행 계획을 작성하고`,  
`3️⃣ 이들의 비용을 연산하고`, 가장 낮은 비용을 가진 실행 계획을 선택한다. 

접근법의 수가 많이 나온다면 그 비용을 계산하고 비교해야한다. 이 작업은 사용자가 직접 하기에는 매우 번거롭다.  
RDB가 데이터 접근의 절차 지향 결정을 자동화하는 이유는 이런 귀찮은 일을 기계적으로 처리해주기 위함이다.


**카탈로그 매니저**

`4️⃣ 옵티마이저가 실행계획을 세울 때 옵티마이저에게 중요한 정보를 제공한다.` 카탈로그란 DBMS 내부 정보를 모아놓은 테이블로  
테이블 또는 인덱스의 통계 정보가 저장돠어 있다. 따라서 카탈로그를 간단하게 `통계 정보`라고 부르기도 한다. 

카탈로그 정보와 테이블 또는 인덱스의 실제와 일치하지 않을 경우 잘못된 실행 계획을 생성할 수 있는 위험이 있다.

```text
[책 내용과 무관]
- Mysql에서 innodb_index_stats 라는 테이블을 조회하면 현재 Index 통계 정보를 확인할 수 있다. 
```


**플랜 평가**
`5️⃣ 옵티마이저가 SQL 구문에서 여러개의 실행 계획을 세운 뒤 그것을 받아 최적의 실행계획을 선택하는 것이 플랜 평가이다.`
이렇게 해서 하나의 실행 계획이 선택되면 DBMS는 실행 계획을 절차적인 코드로 변환하고 데이터 접근을 수행한다.


### 옵티마이저와 통계 정보
옵티마이저 내부에서 일어나는 처리는 엔진을 구현하는 엔지니어 외에는 크게 관계가 없다.  

DBMS 사용자는 내부에서 일어나는 처리보다 옵티마이저를 잘 사용하는 것이 중요하다. 이유는 옵티마이저가 항상 최적의 실행계획을 계산해내는 것이 아니기 떄문이다.
특히 카탈로그가 관리하는 통계 정보에 대해서는 데이터베이스 엔지니어가 항상 신경을 써줘야 한다.

플랜 선택을 옵티마이저에게 맡기는 경우, 최적의 플랜이 선택되지 않는 경우가 종종 발생하는데, 이는 통계 정보가 부족하거나
최신화되지 않았을 때가 대표적인 원인이 된다. DBMS 구현에 따라 차이가 있겠지만 카탈로그에 포함되어있는 통계 정보는 다음과 같다.

- 각 테이블의 레코드 수
- 각 테이블의 필드 수와 크기
- 필드의 카디널리티(값의 개수)
- 필드값의 히스토그램(얼마나 분포되어 있는지)
- 필드 내부에 있는 NULL 수
- 인덱스 정보

이러한 통계 정보를 활용하여 옵티마이저는 실행 계획을 세운다. 떄문에 통계 정보가 실제 데이터와 일치하지 않거나 부족하면  
잘못된 실행계획을 세우게 되는 것이다. 처음 테이블을 생성하면 레코드 0개로 카탈로그 정보가 저장된다. 이 상태에서 100개의 데이터를   
추가로 등록하고 카탈로그를 갱신하지 않으면 옵티마이저는 0개의 데이터를 기준으로 플랜을 생성하게 될 것이다.

"Garbage In, Garbage Out"



### 최적의 실행 계획이 작성되게 하려면 
올바른 통계 정보가 모이는 것은 SQL에 성능에 있어서 중요한 문제이다. 따라서 테이블의 정보가 바뀌면 카탈로그도 갱신해야한다.  
하지만 카탈로그를 갱신하는 작업은 실행 비용이 비싼 작업이기 때문에 데이터가 변경될 떄마다 매번 카탈로그를 갱생하게 되면 성능에 악 영향을 끼칠 수 있다.  
그렇다고해서 갱신 주기가 너무 늦으면 최적의 플랜을 선택하는 것에 있어 어려움이 발생하므로 적절한 주기로 카탈로그를 갱신해야 한다.


```text
통계 정보가 한 번도 수집되지 않거나, 쿼리가 실행될 때마다 통계 정보를 수집하는 기능을 가진 DBMS도 있다. 이러한 것을 JIT 통계라고 부른다. 
그러나 통계 정보 수집이라는 행휘 자체가 시간이 꽤 걸리는 작업이므로 쿼리를 실행할 떄마다 통계 정보를 실시간으로 수집하게 되면 
JIT가 지연을 일으켜 버리는 본말전도가 될 수 있다.
```