# 단위 테스트 

### 제대로된 테스트 코드
- 테스트를 자동화 하는 것보다 `제대로 된 테스트 케이스`를 작성하는 것이 더 중요하다.

### TDD 법칙 세가지

```text
1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.
```

- 위 세가지 규칙을 따르면 개발과 테스트가 30초 주기로 묶인다. 테스트 코드와 실제 코드가 거의 함께 나온다.
- 사실상 위 순서대로 일하게 되면 실제 코드를 전부 테스트하는 테스트 케이스가 나온다. 

### 깨끗한 테스트 코드 유지하기
- 지저분한 테스트 코드는 테스트를 안하는 것과 별 다를 것 없다.
- 실제 코드가 변할 때 테스트 코드도 같이 변해야하기 때문에 테스트가 지저분할 수록 문제가 된다.
- 테스트 코드가 복잡할수록 실제 코드를 짜는 시간보다 테스트 케이스를 추가하는 시간이 더 걸리기 십상이다.
- 결국 테스트 코드는 실제 코드 못지 않게 중요하다. 테스트에 쏟아 부은 노력이 허사로 돌아가지 않으려면 `깨끗한 단위 테스트`를 만들어야 한다.

### 테스트가 제공하는 세가지 장점
- 테스트는 유연성, 유지보수성, 재사용성을 제공한다. 그러나 이 장점들은 `깨끗한 단위 테스트`를 유지했을 때만 얻을 수 있다.
- 테스트 케이스가 없으면 실제 코드를 유연하게 만드는 버팀목도 사라진다. `유연성`, `유지보수성`, `재사용성`을 제공하는 버팀목이 바로 단위 테스트이다.
- 테스트 케이스가 없으면 개발자는 변경을 주저한다. 변경한 코드가 어떤 버그를 만들어낼지 알 수 없기 때문이다.
  - 테스트 케이스가 존재한다면 변경이 쉬워진다는 의미


### 깨끗한 테스트 코드
- 깨끗한 테스트 코드를 만들려면 가장 중요한 것은 `가독성`이다.
- 테스트 코드에서 가독성을 높이려면 `명료성`, `단순성`, `풍부한 표현력` 이 필요하다.
- 테스트 코드는 최소한의 표현으로 많은 것을 나타내야 한다.

### 깨끗한 테스트 코드를 해치는 것
- 중복되는 코드는 테스트를 이해하기 어렵게 만든다.
- 테스트 케이스를 이해하는데 불필요한 코드들은 테스트 코드를 이해하기 어렵게 만든다. 

```java
// 예시 1 - (나쁜 예시)
public void testGetPageHieratchyAsXml() throws Exception 
{
    crawler.addPage(root, PathParser.parse("PageOne"));
    crawler.addPage(root, PathParser.parse("PageOne.ChildOne"));
    crawler.addPage(root, PathParser.parse("PageTwo"));
    
    
    request.setResource("root");
    request.addInput("type", "pages");
    Responder responder = new SerializedPageResponder();
    SimpleResponse response =
        (SimpleResponse) responder.makeResponse(
                new FitNessContext(root), request);
    String xm = response.getContent();
    
    assertEquals("text/xml", response.getContextType());
    assertSubString("<name>PageOne</name>", xml);
    assertSubString("<name>PageTwo</name>", xml);
    assertSubString("<name>ChildOne</name>", xml);
    
}

// 예시 2 - (좋은 예시)
public void testGetPageHierachyAsXml() throw Exception {
        makePage("PageOne", "PageOne.ChildOne", "PageTwo");
        
        submitReqeust("root", "type:pages");
        
        assertResponseIsXml();
        assertResponseContains(
          "<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>"      
        );
}
```
- 예시 2번은 BUILD-OPERATE-CHECK 패턴과 같은 구조라고 볼 수 있다. 
- 예시 2번은 명확히 세 부분으로 나눠진다. 
  1. 첫번째는 테스트 자료를 만든다. (BUILD)
  2. 두번째는 테스트 자료를 조작한다. (OPERATE)
  3. 세번쨰는 조작한 결과가 올바른 지 확인한다 (CHECK)

### 도메인에 특화된 테스트 언어
- 테스트에서만 사용되는 특수 API를 만들어서 테스트 코드 작성과 이해를 도울 수 있다.

### 이중 표준 
- 테스트 API 코드에 적용하는 표준은 실제 코드에 적용하는 표준과 확실히 다르다.
- 테스트 코드도 간결하고 표현력이 풍부해야하지만, 실제 코드만큼 효율적일 필요는 없다. 
- 실제 운영환경과 다르게 테스트 환경은 자원이 제한적일 가능성이 낮기 때문에 성능보다 가독성을 신경써도 큰 문제가 되지 않는다.
  - 예를 들면 메모리를 절약하기 위해 StringBuffer를 사용하지 않고 가독성을 높이기 위해 직접 String 연산을 해도 된다는 것

### 테스트 함수마다 한 개념만 테스트하라
- 하나의 테스트 함수에서 잡하단 개념을 연속적으로 테스트하는 긴 함수는 피하는 것이 좋다.
- 하나의 테스트에 여러가지 개념을 테스트하게 되면 의도를 파악하기 어려워진다.
- 한 테스트에서 assert가 여러개 있는 것이 문제가 아닌, 한 테스트에서 여러 개념을 검증하는 것이 문제이다.

### F.I.R.S.T
깨끗한 테스트는 다음 다섯가지 규칙을 따른다.

- **Fast (빠르게)**
  - 테스트는 빨리 돌아야한다. 테스트가 느리면 자주 돌릴 엄두를 못 낸다.
  - 테스트를 자주 돌리지 않으면 초반에 문제를 찾아 고치기 어렵다.

- **Independent (독립적으로)**
  - 각 테스트는 서로 의존하면 안 된다. 한 테스트가 다음 테스트가 실행될 환경을 준비해서는 안된다.
  - 각 테스트는 `독립적`으로 그리고 어떤 순서로 실행해도 괜찮아야 한다.
  - 테스트가 서로 의존적이면 실패도 연속적으로 일어나고 원인을 진단하기 어려워진다.

- **Repeatable (반복가능하게)**
  - 테스트는 어떤 환경에서도 반복 가능해야 한다.
  - 테스트가 돌아가지 않는 환경이 하나라도 있다면 테스트가 실패한 이유를 둘러댈 변명이 생긴다.

- **Self-Validating (자가검증)**
  - 테스트는 bool 값으로 결과를 내야 한다. 성공이 아니면 실패다.
  - 통과 여부를 알리고 로그 파일을 읽게 만들어서는 안된다.
  - 테스트가 스스로 성공과 실패를 가늠하게 해야한다.

- **Timely (적시에)**
  - 테스트는 적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 적전에 구현한다.
  - 실제 코드를 구현한 다음에 테스트 코드를 만들면 실제 코드가 테스트하기 어렵다는 사실을 발견할지도 모른다.
