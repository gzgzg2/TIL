# 1부 3장 - HTTP 메시지 
> HTTP가 인터넷의 배달원이라면,  
> HTTP 메세지는 무언가를 담아 보내는 소포와 같다.


## 메시지의 흐름
- HTTP 메시지는 클라이언트, 서버, 프록시 사이를 흐른다.
- HTTP 메시지는 애플리케이션 간에 주고받은 데이터들의 블록들이다. 
- HTTP 메시지는 시작줄, 헤더, 본문으로 나뉜다. 본문은 필요에 따라 있을 수도 있고 없을 수도 있다.
- 메시지가 서버로 향하는 것은 `인바운드`로 이동하는 것이고, 요청이 끝난 후 클라이언트로 흐르는 것은 `아웃바인드`로 이동하는 것이다.
- 요청과 응답에 관계없이 모든 메시지는 `다운스트림`으로 흐른다. 메시지 발송자는 수신자의 `업스트림`이다.

## 메시지의 각 부분
- 메시지는 시작줄, 헤더, 본문 세 부분으로 이루어진다.
- 각 메시지는 클라이언트로부터의 요청이나 서버로부터의 웅답 중 하나를 포함한다.
- 메시지 시작줄은 해당 메시지가 어떤 메시지인지 서술하고 헤더 블록은 메시지의 속성을 나타낸다.
- 본문은 텍스트나 이진 데이터를 포함할 수 있고 그냥 비어있을 수도 있다.
- 시작줄과 헤더는 단순한 텍스트으로 이루어져 있다.

## 메시지 문법
### 1. 요청 메시지
> <메서드> <요청 URL> <버전>  
> <헤더>  
> <공백>  
> <엔터티 본문>  

**메서드**
- 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작
- EX) 클라이언트가 "GET" 메서드로 요청할 경우 서버에게 특정 리소스를 반환해달라는 의미

| 메서드    | 설명                                  | 메시지 본문이 있는가?  |
|--------|-------------------------------------|---------------|
| GET    | 서버에서 문서를 가져온다.                      | 보통 없지만 있을수도 있음 |
| HEAD   | 서버에서 어떤 문서에 대해 헤더만 가져온다.            | 없음            |
| POST   | 서버가 처리해야 할 데이터를 보낸다.                | 있음            |
| PUT    | 서버에 요청 메시지의 본문을 저장한다. 이미 존재하면 덮어씌운다. | 있음            |
| TRACE  | 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다.     | 없음            |
| OPTIONS | 서버가 어떤 메서드를 수행할 수 있는지 확인한다.         | 없음            |
| DELETE | 서버에서 문서를 제거한다.                      | 없음            |

**요청 URL**
- 요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성요소

**버전**
- 이 메시지에서 사용중인 HTTP의 버전
- HTTP 애플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 말해주기 위한 수단
- 대화 상대의 능력과 메시지의 형식에 대한 단서를 제공하기 위한 것
- EX) HTTP/<메이저>.<마이너>


### 2. 응답 메시지
> <버전> <상태 코드> <사유 구절>  
> <헤더>  
> <공백>  
> <엔터티 본문>  

**상태코드**
- 요청 중에 무엇이 일어났는지 설명하는 세 자리의 숫자

**사유 구절**
- 숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구

### 3. 공통되는 구성요소

**시작줄**
- 모든 HTTP 메시지는 시작줄로 시작한다.
- 요청 메시지의 시작줄은 서버가 무엇을 해야하는지 말해준다.
- 응답 메시지의 시작줄은 요청 처리중에 무슨 일이 일어났는지 말해준다.

**헤더**
- 시작줄 다음에는 0개, 1개 혹은 여러 개의 HTTP 헤더가 포함될 수 있음
- HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더한다. 
- 헤더는 `이름:값` 쌍의 목록이다.
  - Content-length: 19

**엔터티 본문**
- 엔터티 본문은 선택적이다. 
- 엔터디 본문은 HTTP 메시지의 화물이라고 할 수 있다. 
- 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션 등 여러 종류의 디지털 데이터를 실어 나를 수 있다.

### 4. 버전 0.9 메시지
- HTTP/0.9의 요청 메시지는 메서드와 요청 URL 만을 가지고 있다. 
- HTTP/0.9의 응답 메시지는 오직 엔터티로만 되어있다. 상태코드나 사유구절, 헤더도 존재하지 않는다.

## 메서드
> 모든 서버가 모든 메서드를 구현하고 있는 것은 아니다.  
> 서버가 모든 메서드를 구현하지 않았더라도 메서드는 대부분 제한적으로 사용될 것이다.

### 1. 안전한 메서드
- GET과 HEAD 메서드는 안전한 메서드로 분류할 수 있다. 
- 안전한 메서드란 요청의 결과로 서버에 어떤 작용도 없음을 의미한다.
- 그렇다고 해서 안전한 메서드가 서버에 작용을 유발하지 않는다는 보장은 없다(웹 개발자에게 달렸음)
---
**GET**
- 가장 흔히 쓰이는 메서드. 주로 서버에게 리소스를 달라고 요청할 때 쓰임
- HTTP/1.1은 서버가 이 메서드를 구현할 것을 요구함

**HEAD**
- GET처럼 행동하지만 서버는 응답으로 헤더만을 돌려준다.
- HEAD 메서드는 리소스를 가져오지 않고도 그에 대해 무엇인가를 알아낼 수 있다.
- 서버 개발자는 반드시 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야한다.
- HTTP/1.1 준수를 위해서는 HEAD 메서드가 반드시 구현되어 있어야 한다.

**PUT**
- PUT 메서드는 서버에 문서를 쓴다. 
- 서버가 요청의 본문을 가지고 새 문서를 만들거나 이미 존재하면 덮어씌운다.
- PUT은 콘텐츠를 변경할 수 있게 해주기 때문에 제한적으로 사용해야 안전하다.
  - 로그인을 요구 등등

**POST**
- POST 메서드는 서버에 입력 데이터를 전송하기 위해 설계되었음
- HTML form을 지원하기 위해 흔히 사용 됨

**TRACE**
- TRACE는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.
- TRACE 요청은 목적지 서버에서 `루프백(loopback)` 진단을 시작한다. 
- TRACE 요청의 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답을 되돌려준다.
- 보통 진단을 위해 사용된다.
  - EX) 요청이 의도한 요청/응답 연쇄를 거쳐가는지
  - EX) 프록시나 다른 애플리케이션들이 요청에 어떤 영향을 미치는지
- TRACE는 중간 애플리케이션이 여러 다른 종류의 요청을 일관되게 다룬다고 가정하는 문제가 발생할 수 있다.
  - 예를들면 프록시 서버는 POST 요청을 바로 서버로 통과시키는 반면 GET은 웹 캐시와 같은 다른 HTTP 애플리케이션으로 전송한다.
  - TRACE는 메서드를 구별하는 메커니즘을 제공하지 않기 때문에 TRACE 요청을 어떻게 처리할 것인지에 대해서는 중간 애플리케이션이 결정을 내린다.

**OPTIONS**
- OPTIONS 메서드는 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다.
- 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다.

**DELETE**
- DELETE 메서드는 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다.
- 그러나 클라이언트는 삭제가 수행되는 것을 보장하지 못한다. 
  - HTTP 명세는 서버가 클라이언트에게 알리지않고 요청을 무시하는 것을 허용하기 떄문에

## 상태코드
> 상태 코드는 클라리언트에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법을 제공한다.

### 100-199: 정보성 상태 코드
- 정보성 상태 코드는 HTTP/1.1에서 도입되었다. 
- 복잡함을 감수할 만한 가치가 있는지에 대해 논란이 되고 있다.

### 200-299: 성공 상태 코드
- 성공 상태 코드는 클라이언트의 요청이 성공했을 때 반환된다.
- 자주 사용되는 상태 코드로는 200, 201이 있다.

**200**
  - 요청은 정상이고, 엔터티 본문은 요청된 리소스를 포함하고 있다는 의미

**201**
  - 서버 개체를 생성하라는 요청을 위한 상태 코드
  - 생성된 리소스에 대해 구체적인 참조가 담긴 Location 헤더나 참조할 수 있는 URL을 본문에 포함해야 한다.

### 300-399: 리다이렉션 상태 코드
> 리다이렉션 상태 코드는 클라이언트가 원하는 리소스에 대해 다른 위치를 사용하라고 말해주거나  
> 그 리소스의 내용 대신 다른 대안 응답을 제공한다. 
- 클라이언트가 요청한 리소스가 옮겨졌다면 클라이언트에게 리다이렉션 코드와 Location 헤더 필드로 위치를 알린다.
- 리다이렉션 상태 코드 중 몇몇은 리소스에 대한 애플리케이션의 로컬 복사본이 원래 서버와 비교했을 때 유요한지 확인하기 위해 사용한다.

### 400-499: 클라이언트 에러 상태 코드
- 클라이언트의 요청이 잘못 되었을 때 알리는 상태 코드
- 자주 만나는 상태 코드로는 400, 401, 403, 404 등이 있다.

**400**
- 클라이언트가 잘못된 요청을 보냈을 떄

**401**
- 리소스를 얻기전에 클라이언트에게 스스로를 인증하라고 요구하는 상태 코드

**403**
- 요청이 서버애 의해 거부되었음을 알리는 상태 코드

**404**
- 요청한 URL을 서버가 찾을 수 없음을 알리는 상태 코드

### 500-599: 서버 에러 상태 코드
- 클라이언트가 올바른 요청을 보냈음에도 서버 자체에서 에러가 발생하는 경우에 알리는 상태 코드

**500**
- 서버가 요청을 처리할 수 없게 만드는 에러를 만났을 때 사용되는 상태 코드

**501**
- 클라이언트가 서버의 능력을 넘은 요청을 했을 때 (서버가 지원하지 않는 메서드 사용)

**502**
- 프록시나 게이트웨이처럼 행동하는 서버가 그 요청을 응답 연쇄에 있는 다음 링크로부터 가짜 응답에 맞닥뜨렸을 때 사용되는 상태 코드
  - EX) 자신의 부모 게이트웨이에 접속하는 것이 불가능 할 때

**503**
- 현재는 서버가 요청을 처리할 수 없지만 나중에는 가능함을 알리는 상태 코드
- Retry-After 헤더에 언제 리소스를 사용가능한지 알릴 수 있다.

**504**
- 다른 서버에게 요청을 보내고 기다리다 타임아웃이 발생했을 때 나타나는 상태코드
- 408과 비슷하지만 타임아웃이 발생한 게이트웨이나 프록시에서 온 응답이라는 점이 다르다.

## 헤더
> 헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용된다.   
> 헤더에는 특정 종류의 메시지에만 사용할 수 있는 헤더와, 더 일반 목적으로 사용할 수 있는 헤더,  
> 그리고 응답과 요청 메시지 양쪽 모두에서 정보를 제공하는 헤더가 있다.

### 일반헤더(General Header)
- 일반헤더는 클라이언트와 서버 양쪽 모두가 사용한다.
- 클라이언트, 서버, 그리고 어딘가에 메시지를 보내는 다른 애플리케이션들을 위해 다양한 목적으로 사용된다.

---
### 요청헤더(Request Header)
- 요청헤더는 요청 메시지를 위한 헤더이다.
- 클라이언트가 받고자 하는 데이터 타입이 무엇인지와 같은 부가 정보를 제공한다.

**Accept 관련헤더**
- Accept 관련 헤더는 클라이언트와 서버 양쪽 모두에게 유익하다.
- 클라이언트는 원하는 것을 얻을 수 있다. 
- 서버는 클라이언트가 사용하지 못하는 것을 전송하는 데 시간과 대역폭을 낭비하지 않을 수 있다.

**조건부 요청 헤더**
- 조건부 요청 헤더를 사용하면 클라이언트는 서버에게 요청에 응답하기 전에 먼저 조건이 참인지 확인하게 하는 제약을 포함할 수 있다.
  - EX) `if-Modified-Since`는 주어진 날짜 이후에 리소스가 변경되지 않았다면 요청을 제한한다.

**요청 보안 헤더**
- 클라이언트가 리소스에 접근하기 전에 자신을 인증하게 함으로써 트랜잭션을 더 안전하게 만들고자 한다.
---- 
### 응답헤더(Response Header)
- 응답 메시지는 클라이언트에게 정보를 제공하기 위한 목적으로 사용된다.
- EX) 클라이언트가 어떤 종류의 서버와 대화하고 있는지 등등

---
### 엔터티 헤더(Entity Header)
- 엔터티 본문에 대한 헤더이다. 엔터티 헤더는 본문에 들어있는 데이터 타입이 무엇인지 말해줄 수 있다.

**콘텐츠 헤더**
- 콘텐츠 헤더는 엔티티 콘텐츠에 대한 구체적인 정보를 제공한다. 
- 웹 브라우저는 내용 유형을 기술한 Content-Type 헤더를 보고 그 객체를 어떻게 출력할지 결정할 수 있다.  

---
### 확장 헤더(Extension Headers)
- 확장 헤더는 애플리케이션 개발자들에 의해 만들어졌지만 아직 명세서에 추가되지않은 비표준 헤더이다.
- HTTP 프로그램은 확장 헤더들에 대해 의미를 모른다고 해도 용인하고 전달해야 할 필요가 있다.
---