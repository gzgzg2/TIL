# 4.2 체크 예외(checked exception)만 던지세요

## 정리

### 1. 체크 예외(checked)와 언체크(unchecked) 예외의 차이

- `체크(checked)예외`는 문제를 처리할 `책임`을 호출자에게 넘긴다. 호출자는 책임을 `전파`하면서 메서드가 안전하지 않다고 선언할 수 있다.
- 체크예외는 예외가 발생할 수 있다는 사실을 무시할 수 없다. 예외를 잡거나 상위로 전파하기 위해 예외를 선언해야 하기 때문에 항상 `가시적`이다.
- `언체크(uncheked)예외` 는 무시할 수 있고 예외를 잡지 않아도 무방하다.  언체크 예외를 던지면 누군가 예외를 잡기 전까지는 상위로 전파된다.
- `언체크(uncheked)예외` 는 호출자에게 예외가 던져질 수 있다는 사실을 알리지 않는다. 따라서 해당 메서드를 호출하는 쪽에서는 어떤 예외가 던져질지 예상할 수 없다.
- 언체크 예외의 경우 예외타입을 선언하지 않아도 무방한 반면에 체크 예외는 항상 예외 타입을 공개해야 한다.

### 2. 꼭 필요한 경우가 아니라면 예외를 잡지 마세요

- 가능하면 예외를 제일 높은 레벨로 `전파` 하여라
- 이상적인 설계에서는 애플리케이션의 진입점 별로 오직 하나의 catch 문만 존재해야 한다.
- 문제가 발생한 장소에서 예외를 잡을 경우 `안전하게 실패하기` 방식과 비슷한 이유로 유지보수를 어렵게 한다.
    - 문제가 발생하는 것을 은폐하기 때문에
    - 이러한 접근 방법을 `흐름 제어를 위한 예외 사용(using exceptions for flow contorl)` 이라고 부른다.
- 문제가 발생한 장소에서 null이나 -1 값을 리턴할 경우 클라이언트는 반환값을 신뢰할 수 없게 된다.



**흐름제어를 위한 예외 사용 예시**

```java
public int length(File file) {
	try {
		return content(file).length();
	} catch (IOException ex) {
		return 0; 
	}
}
```

파일이 정상적으로 존재하는 경우에도 0을 반환할 수 있기 때문에 좋은 방식이 아니다. 실제로 문제가 발생하여 0을 리턴했을 경우에 클라이언트가 문제를 찾는데 많은 시간이 소요될 수 있다.

**예외를 분기처리를 이용하여 해결하는 경우**

```java
public int length(File file) {
	if (/* 파일 시스템에 문제가 있으면 */) {
		return 0;
	} else {
		return content(file).length();
	}
}
```

예외는 오퍼레이션의 정상적은 흐름을 종료시키고 추가적인 조치를 필요로 하는 심각하고 복구 불가능한 상황을 나타내기 위하여 설계된 것이다. 따라서 예외를 통해 분기처리하는 방식은 옳지않다.

### 3. 항상 예외를 체이닝하세요

- 문제를 발생시킨 낮은 수준의 `근본 원인(root cause)` 을 소프트웨어의 더 높은 곳으로 이동시켜라.
- 예외를 잡은 즉시 새로운 예외로 감싸서 상위로 예외를 이동시키는 방법을 `예외 체이닝(Exception chaining)`이라고 한다.
- 예외를 상위로 이동할 때 문제를 발생시킨 근본원인의 정보를 손실되게 하지 않아야 한다.
- 항상 예외를 체이닝하고 절대로 원래 예외를 무시해서는 안된다.

```java
public int length(File file) throws Exception {
	try {
		return content(file).length();
	} catch (IOException ex) {
		throw new Exception("길이를 계산할 수 없다.", ex);
	}
}
```

예제 코드처럼 예외를 잡은 즉시 새로운 예외를 던지는 방법을 `예외 체이닝(Exception chaining)` 이라고 한다. 이러한 방식은 원래의 예외를 새로운 문제로 대처함으로써 문제가 발생했다는 사실을 무시하지 않는다. 대신 원래의 문제를 새로운 문제로 감싸서 함께 상위로 던진다.

### 4. 단 한번만 복구하세요

- 무조건 예외를 잡아서는 안된다는 주장은 옳지않다. 딱 한번은 복구해야 한다.
- 예외를 복구하는 장소는 애플리케이션의 가장 높은 레벨에서 해야한다.
- 항상 예외를 잡고, 체이닝하고, 다시 던져라. 그리고 가장 최상위 수준에서 오직 한번만 복구하여라

```java
public class App {
	public static void main(String... args) {
		try {
			System.out.println(new App().run());
		} catch (Exception ex) {
			System.err.println(
				"죄송하지만 문제가 발생했습니다:" + ex.getLocalizedMessage();
			);
		}
	}
}
```

main 메서드는 애플리케이션의 가장 높은 레벨에 존재하기 때문에 종료되지 않는다. main보다 더 높은 곳에는 그 어떤 것도 존재하지 않을 것이다. 만약 가장 높은 곳에서 예외를 catch 하지 않을 경우 JVM이 예외를 잡게 되어 스택 트레이스 전체를 노출하는 시스템 메세지가 출력될 것이다.

때문에 애플리케이션의 `가장 높은 곳`이 복구하기에 적합한 유일한 장소이다

## 느낀점

음 .. 실제로 checked 예외보다 unchecked 예외를 주로 사용한 것 같다.

값이 없거나 잘못된 연산을 할 경우 실행을 종료시키기 위해 예외를 던지곤 했는데, 클라이언트가 메서드를 호출할 때 이 메서드가 어떠한 예외를 던지는지 알 수 없는 것은 혼란을 줄 수 있다는 생각이 들었다.

흠 그런데 예외를 잡지 않고 시스템을 종료시키고 싶을 때는 어떤 방법을 사용해야할지.. 아직 감이 오지 않는다. 호출자가 신경쓰지 않고 메서드 자체에서 문제가 발생했을 때 시스템을 복구하는 것이 아닌 종료하고 싶을 때는 어떻게 해야하는지? 아니면 이러한 상황 자체가 나쁜 설계인 것일까??

실제로 checked 예외를 던져야 하는 상황에서만 예외를 던져보고 비교해봐야 할 것 같다. 느낀점에서 좀 부정적으로 생각하는 거처럼 보이는데 `예외 체이닝` 방법과 최상위 애플리케이션에서 예외를 잡는 방법에 대해서는 호의적이다.