# 함수
> 프로그래밍 초창기에는 시스템을 루틴과 하위 루틴으로 나눴다. 포트란과 PL/1 시절에는
> 시스템을 프로그램, 하위 프로그램, 함수로 나눴다. 지금은 함수만 살아남았다.
> 어떤 프로그램이든 가장 기본적인 단위가 함수다.


### 작게 만들어라!
- 함수를 만드느 첫번째 규칙은 '작게!'다. 함수를 만드는 두번째 규칙은 '더  작게!'다. 결론은 함수가 작을 수록 좋다는 것
- if문/else 문/while문 등에 들어가는 블록은 한 줄이여야 한다.

### 한가지만 해라!
- 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야한다. 그 한 가지만을 해야한다.
- 한 가지란 단 한줄의 라인만 존재하라는 것이 아닌 추상화 수준이 하나인 단계만 실행하라는 것
  - 함수를 변경하는 이유가 하나라면 그 함수는 한 가지 일을 한다고 볼 수 있음
- 다른 의미를 가진 이름으로 다른 함수를 추출하고 있다면 그 함수는 여러 작업을 하는 셈이다.

**함수 당 추상화 수준은 하나로!**
- 함수가 `한 가지` 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.


**내려가기 규칙**
- 코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.


**추상화 수준이란?**

`높은 추상화 수준`
- 예를 들면 getHtml()은 추상화 수준이 높다고 볼 수 있다. html을 가져오는 것 외에는 아무런 정보도 알 수 없기 때문이다.

`보통 추상화 수준`
- String pagePathName = PathParser.render(pagePath) 같은 코드는 추상화 수준이 보통이라고 할 수 있다.
- `render(pagePath)` 는 PathParser를 이용해 pagePathName을 가져온 다는 것을 알 수 있고 어떠한 인자와 연관되어 있는지도 유추가 가능하기 때문이다.


`낮은 추상화 수준`
- .append("\n) 같은 코드는 추상화 수준이 아주 낮다고 볼 수 있다. 연관된 정보를 모두 알 수 있고 함수의 역할까지 전부 유추할 수 있기 때문이다.

### 서술적인 이름을 사용하라!
- 길고 서술적인 이름이 길고 서술적인 주석보다 좋다.
- 한 가지만 하는 작은 함수에 좋은 이름을 붙인다면 깨끗한 코드에 절반 가까워진다.
- 뚜렷한 이름을 사용하면 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다.

### 함수 인수
- 함수에서 이상적인 인수 개수는 0개이다. 그 다음은 1개이고 그 다음은 2개다. 3개는 가능한 피하는 게 좋다.
- 입력 인수를 변환하는 함수라면 변환 결과는 반환값으로 돌려준다.
  - ex) `void convertTo(Member member)`와 같은 형식을 지양하자.
- 플래그 인수는 함수가 한꺼번에 여러가지일을 처리한다고 대놓고 공표하는 것과 같다.
- 이항 함수는 어느 인자가 어느 순서에 들어가야 하는지 인위적으로 기억해야하기 때문에 가능하면 단항 함수를 생성하자.
- 인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어본다.
- 일반적으로 출력 인수는 피해야 한다.

### 동사와 키워드
- 함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수이다.
- 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야한다.

### 부수 효과를 일으키지 마라!
- 함수 명에 함수의 행동이 나타나지 않는 경우 부수효과를 초래할 수 있다.
  - `checkPassword`라는 함수에서 세션을 초기화 하는 경우, 세션을 초기화 한다는 사실을 알기 힘들다.

### 명령과 조회를 분리하라!
- 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다.

### 오류코드보다 예외를 사용하라!
- 명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다.

```java
 if (deletePage(page) == E_OK)
```

위 코드는 동사/형용사 혼란을 일으키지 않는 대신 여러 단계로 중첩되는 코드를 야기한다.


### 오류 처리도 한 가지 작업이다.
- 함수에 키워드 try가 있다면 함수는 try 문으로 시작해 catch/finally 문으로 끝나야한다.

```java

void updateId(String id) {
  
    try {
        // 아이디 확인
      } catch (UserNotFoundException e) {
       // 예외처리
      }
    
    // 부가작업 수행 ..
  
  }
```
예제처럼 예외처리 이후에 부가작업을 수행하는 코드는 지양할 것!

### 의존성 자석
- 오류코드를 반환한다는 것은 어디선가 오류 코드를 정의한다는 것. 이러한 클래스를 의존성 자석이라고 함.
  - 오류코드가 정의된 클래스가 변할 경우 오류코드를 사용하는 모든 클래스를 컴파일 해야한다.

### 반복하지 마라!
- 중복은 소프트웨어에서 모든 악의 근원이다. 많은 원칙과 기법이 중복을 없애거나 제어할 목적으로 나왔다.
- 구조적 프로그래밍, AOP, COP 모두 이떤 면에서는 중복 제거 전략이다.

### 함수를 어떻게 짜죠?
- 처음부터 완벽한 함수를 짜려고 하지 말아라. 빠르게 구현하고 단위 테스트를 만든다음 원하는 대로 읽힐 때까지 코드를 다듬고 고친다.

### 결론
- 대가 프로그래머는 시스템을 구현한 프로그램이 아니라 풀어갈 이야기로 여긴다.
- 이 장에선 함수를 잘 만드는 기교를 설명했지만 진짜 목표는 시스템이라는 이야기를 풀어나가는 데 있다. 