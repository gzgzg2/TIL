# 예외
> 자바 개발자가 가장 신경쓰기 귀찮아 하는 것 중 하나인 예외처리
> 
> 4장에선 잘못된 예외처리 때문에 일어나는 문제에 대해서 알아보고 예외를 처리하는 베스트 프랙티스를 살펴본다.


### 예외 블랙홀
```java
try {
    
    } catch(SQLException e) {

}
```
예제처럼 예외가 발생하여도 아무런 작업도 하지 않고 프로그램 실행을 계속하는 것은 매우 위험하다. 
발생한 예외에 대해 아무런 처리가 없는 경우에는 프로그램 실행 중 오류가 발생하여도 인지하기 어렵기 때문이다. 
그리고 발생한 예외로 메모리나 리소스가 소진되는 등 예상치 못한 다른 문제를 일으킬 수 있다. 
결국 다른 문제가 발생하여 시스템이 오작동 하면 그떈 문제의 원인을 찾아내는 것이 매우 힘들 것이다. 

예외 처리할 때 반드시 지켜야할 핵심 원칙은 한가지다. 
모든 예외는 적절하게 **복구되거나** 작업을 중단시키고 **운영자 또는 개발자에게 분명하게 통보**돼야한다.


### 무의미하고 무책임한 throws
```java
public void method1() throws Exception {
        method2();
}

public void method2() throws Exception {
        method3();
}

public void method3() throws Exception {

        }
```
예제 코드처럼 throws Exception을 기계적으로 붙일 경우 예외 블랙홀 보다는 
괜찮은 경우이지만 이러한 무책임한 throws Exception에도 심각한 문제점이 있다.

Exception은 Exception들의 최상위 클래스이므로 구체적인 예외가 발생하여도
Exception 타입으로 캐스팅될 수 있다. 때문에 해당 메소드에서 어떠한 예외가 발생할지 예상할 수 없고
적절한 처리를 하기가 어려워진다.

결국 그러한 메소드를 호출하는 메소드에서도 역시 throws Exception을 따라 붙일 수밖에 없어진다.
결과적으로는 적절한 처리를 통해 복구될 수 있는 예외상황도 제대로 다룰 수 있는 기회를 박탈당하는 것이다.

## 예외의 종류와 특징

### Error
`java.lang.Error` 클래스의 서브클래스들은 시스템에 뭔가 비정상적인
상황이 발생했을 경우에 사용된다. 주로 자바 VM에서 발생시키는 것이기 때문에 애플리케이션 코드에서
잡으려고 하는 것은 좋지않다. `OutOfMemoryError`, `ThreadDeath`같은 에러는 catch 블록으로 
잡아봤자 아무런 대응 방법이 없기 때문이다.

### Unchecked Exception
`java.lang.Exception`의 `RuntimeException을 상속받은 서브클래스들`을 
`Unchecked exception`이라고 한다. 에러와 마찬가지로 이 언체크 예외는 catch 문으로 
잡거나 throws로 선언하지 않아도 된다. (명시적으로 잡거나 throws 선언해도 문제되지는 않음)

피할 수 있지만 개발자가 부주의해서 발생할 수 있는 경우에 만든 것이 런타임 예외이다.

### Checked Exception
체크 예외는 체크 예외가 발생할 수 있는 메소드를 사용할 경우 반드시 예외를 처리하는 코드를 작성해야 한다.
사용할 메소드가 예외를 던진다면 이를 catch 하거나 다시 throws를 정의해서 메소드 밖ㅇ로 던져야한다.
그렇지 않을 경우 컴파일 에러가 발생한다.


## 예외처리 방법

### 예외 복구
첫번째 처리 방법은 예외 상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것.
예외가 처리됐으면 비록 기능적으론느 사용자에게 예외상황으로 비쳐도 애플리케이션에서는 정상적으로
설계된 흐름을 따라 진행해야 된다. 

### 예외처리 회피
두번째 방법은 예외처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것.
예외처리를 회피하려면 반드시 다른 오브젝트나 메소드가 예외를 처리할 수 있도록 
예외를 던져줘야한다. 

유의해야할 점은 템플릿/콜백처럼 긴밀하게 역할을 분담하고 있는 것이 아니라면 자신의 코드에서 
발생한 예외를 무책임하게 던지는 책임회피일 수 있다. 

예를 들어 DAO가 무책임하게 SQLException을 생각없이 던져버리면 DAO를 사용하는 
서비스 계층이나 웹 컨트롤러에서 SQLException을 처리하게 된다. 
이 경우 Persistent layer의 구체적인 코드가 윗 계층을 침범하면서 계층간 결합도가 높아지는 
문제가 발생할 수 있다.

템플릿/콜벡처럼 긴밀한 관계에 있는 다른 오브젝트에게 예외처리 책임을 분명하게 지게 하거나, 
자신을 사용하는 쪽에서 예외를 다루는 게 최선이 방법이라는 분명한 확신이 있을 때 예외처리를 
회피하는 것이 바람직하다.

### 예외 전환 
마지막으로 예외를 처리하는 방법은 `예외 전환`을 하는 것이다.
예외 전환은 예외를 자신을 호출하는 다른 오브젝트나 메소드에게 전달하는 점이 예외 회피와 비슷하다.
하지만 예외 전환은 발생한 예외를 그대로 넘기는게 아니라 `적절한 예외로 전환해서` 넘긴다는 특징이 있다.

간단한 예시로 아이디가 같은 사용자가 있어서 DB에러가 발생하면 JDBC는 SQLException을 발생시킨다.
SQLException 만으로는 문제 발생의 원인을 서비스 계층 등에서는 알아차리기 힘들다. 

아이디가 중복되는 경우는 알아차리기 쉬운 예외이므로 발생한 SQLException을 DuplicateUserIdException 같은
예외로 던져주는 것이 좋다. 의미가 분명한 예외가 던져지면 서비스 계층에서는 적절한 복구 작업을 진행할 수 있기 떄문이다.

서비스 계층에서 예외를 전환할 수도 있지만 특정 기술의 정보를 해석하는 코드르 비즈니스 로직을 담은 
서비스 계층에 두는 것은 특정 기술에 대한 결합이 생길 수 있게 된다.








