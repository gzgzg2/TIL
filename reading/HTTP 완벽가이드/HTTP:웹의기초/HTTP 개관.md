# 1부 1장 - HTTP 개관 (웹 클라이언트와 서버)
> HTTP는 전 세계의 웹 서버로부터 대량의 정보를  
> 빠르고, 간편하고, 정확하게 사람들의 PC에 설치된 웹 브라우저로 옮겨준다.  
> HTTP는 신뢰성 있는 TCP/IP 프로토콜을 사용하기 때문에 전송 숭 데이터가 손상되지 않는 것을 보장한다.

## 1.1 웹 클라이언트와 서버의 기본개념
- 웹 콘텐츠는 웹 서버에 존재한다. 웹 서버는 HTTP 프로토콜로 의사소통하기 때문에 HTTP 서버라고 불린다.
- HTTP 클라이언트는 데이터를 `요청`하고 HTTP 서버는 클라이언트가 `요청`한 데이터를 `제공`한다.
- HTTP 클라이언트와 HTTP 서버는 월드 와이드 웹의 기본 요소이다.

## 1.2 클라이언트와 서버의 통신방식
> 우리가 사용하는 가장 흔한 웹 클라이언트는 인터넷 익스플로러나 구글 크롬 같은 웹 브라우저이다.
- 웹 브라우저는 서버에게 HTTP 객체를 요청하고 사용자의 화면에 출력한다.
- 사용자가 "http://www.oreilly.com/index.html" 페이지를 필요로 할 때
  1. 웹 브라우저가 HTTP 요청을 www.oreilly.com 웹 서버로 보낸다.
  2. 서버는 요청받은 객체 "index.html"을 찾고 성공했다면 타입, 길이 정보등과 함께 HTTP 응답에 실어서 클라이언트에게 전송한다.
  3. 클라이언트는 응답받은 데이터를 화면에 출력한다. 

## 1.3 리소스
> 웹 서버는 웹 리소스를 관리하고 제공한다. 가장 단순한 웹 리소스는 웹 서버의 정적파일이며  
> 정적 파일은 텍스트 파일, HTML 파일, 워드 파일 등등 그 외 모든 종류의 파일을 포함한다.  
> 그러나 웹 리소스가 반드시 정적 파일인 것은 아니다. 리소스는 요청에 따라 콘텐츠를 생산하는 프로그램이 될 수도 있다.  
> 동적 컨텐츠는 사용자가 누구인지, 어떤 정보를 요청했는지에 따라 콘텐츠를 생성한다.

### **미디어타입**
- 어떤 종류의 콘텐츠도 리소스가 될 수 있다.
  - 그림 파일, 텓스트 파일, 검색엔진, 웹 게이트 웨이
- 인터넷은 수천 가지 데이터 타입을 다루기 때문에 `MIME(Multipurpose Interbet Mail Extensions) 타입`이라는 데이터 포맷 라벨을 붙인다.
- MIME 타입은 사선(/)으로 주 타입과 부 타입을 구분한다.
  - HTML로 작성된 문서의 경우 MIME 타입은 text/html
- MIME 타입은 수백 가지의 잘 알려진 MINE 타입과 실험용 혹은 특정 목적의 MIME 타입이 존재한다.

### **URI**
- 서버 리소스는 각자 이름을 갖고있다. 서버 리소스 이름은 `통합 자원 식별자(uniform resource identifier)` 혹은 `URI`로 불린다.
- URI는 리소스를 고유히게 식별하고 위치를 지정할 수 있다.
  - http://www.joes-hardware.com/specials/saw-blade.gif 
    - http:// : 스킴, 스킴이란 리소스에 접근하기 위해 사용되는 프로토콜을 의미한다.
    - www.joes-hardware.com : 리소스가 존재하는 서버의 주소
    - /specials/saw-blade.gif : 서버의 리소스 존재 위치
- HTTP는 주어진 URI로 객체를 찾아온다.
- URI에는 `URL`과 `URN`이 존재한다.

### **URL**
- URL(uniform resource locator)은 특정 서버의 한 리소스에 대한 구체적인 위치를 서술한다.
- 리소스가 정확히 어디에 있고 어떻게 접근할 수 있는지 분명히 알려준다.
- 오늘날 대부분의 URI는 URL이다. 

### **URN**
- URN(uniform resource name)이란 리소스 위치에 영향을 받지 않는 유일무이한 이름 역할을 한다.
- URN은 리소스를 여기저기로 옮기더라도 문제없이 동작한다. 리소스의 이름이 변경되지 않으면 여러 종류의 네트워크 접속 프로토콜로 접근할 수 있다.
- 그러나 URN은 리소스 위치를 분석하기 위한 인프라적 지원이 필요하다. 현재는 인프라적 지원이 부재하기에 URN 채택이 늦어지고 있다.

## 1.4 트랜잭션
> HTTP 트랜잭션은 요청명령과 응답 결과로 구성되어 있다.  
> 이 상호작용은 HTTP 메세지라고 불리는 정형화된 데이터 덩어를 이용해 이루어진다.

### **메서드**
- 모든 HTTP 요청은 한 개의 메서드를 갖는다. 
- 메서드는 서버에게 어떤 동작이 취해져야 하는지 알려준다(웹 페이지 가져오기, 게이트웨이 프로그램 실행하기, 파일 삭제하기 등)

|HTTP 메서드| 설명|
|---------| ---|
|GET| 서버에서 클라리언트로 지정한 리소스를 보내라|
|PUT| 클라이언트에서 서버로 보낸 데이터를 지정한 이름의 리소스로 저장하라|
|DELETE| 지정한 리소스를 서버에서 삭제하라|
| POST| 클라이언트 데이터를 서버 게이트웨이 애플리케이션으로 보내라|
|HEAD| 지정한 리소스에 대한 응답에서, HTTP 헤더 부분만 보내라|
HTTP 메서드는 표에서 설정한 메서드 말고도 다양한 메서드가 존재한다.

### **상태코드**
- 모든 HTTP 응답 메세지는 상태 코드와 함께 반환된다. 
- 상태 코드는 클라이언트에게 요청이 성공했는지 아니면 추가 조치가 필요한지 알려주는 세 자리 숫자이다.
- HTTP는 각 숫자 상태 코드에 텍스트로 된 "사유 구절(reason phrase)"도 함께 보낸다.

### **웹페이지는 여러 객체로 이루어질 수 있다**
- 애플리케이션은 보통 하나의 작업을 수행하기 위해 여러 HTTP 트랜잭션을 수행한다.
- 시각적으로 풍부한 웹페이지를 가져올 때 먼저 HTML 뼈대를 하나의 트랜잭션으로 가져오고 이후 첨부된 이미지, 그래픽 조각, 자바 애플릿 등을 가져오기 시작한다.
- 각각의 리소스들은 서로다른 서버에 존재할 수도 있다. 이와같이 웹페이지는 보통 하나의 리소스가 아닌 리소스의 모음이다.

### **메세지**
- HTTP 메세지는 단순한 줄 단위의 문자열이다. 이진 형식이 아닌 일반 텍스트이기 때문에 사람이 읽고 쓰기 쉽다.
- 웹 클라이언트에서 웹 서버로 보낸 HTTP 메세지를 요청 메세지라고 부르고 서버에서 클라이언트로 가는 메세지는 응답 메세지라고 부른다.

## 1.5 메시지

### **HTTP 메세지 구성**

1. 시작줄
   - 메세지의 첫줄로 요청 메세지의 경우 웹 서버가 무엇을 해야하는지, 응답 메세지일 경우 무슨 일이 일어났는지 나타낸다.
2. 헤더
    - 시작줄 다음에는 0개 이상의 헤더 필드가 이어진다. 
    - 헤더필드는 쉬운 구문분석을 위해 쌍점(:)으로 구분되어 있는 하나의 이름과 하나의 값으로 구성되어 있다.
    - 헤더영역의 마지막 줄은 공백으로 끝난다.
3. 본문
   - 공백 다음에는 어떤 종류의 데이터는 들어갈 수 있는 메세지 본문이 필요에 따라 사용된다.
   - 요청의 경우 웹 서버로 데이터를 실어보내고 응답의 경우 클라이언트로 데이터를 반환한다.
   - 시작줄과 헤더와 달리 본문은 임의의 이진 데이터를 포함할 수 있다.

## 1.6 TCP 커넥션
> HTTP는 애플리케이션 계층의 프로토콜이다.  
> HTTP는 네트워크 통신의 핵심적인 세부사항에 대해서는 신경쓰지 않는다. 대신 신뢰성 있는 프로토콜인 TCP/IP에게 맡긴다.   
> TCP/IP는 데이터 전송 순서와 신뢰성이 보장된 프로토콜이다.

### **TCP/IP?**
- TCP/IP는 TCP와 IP가 층을 이루는, 패킷 교환 네트워크 프로토콜의 집합
- TCP/IP는 각 네트워크와 하드웨어의 특성을 숨기고 종류에 구애받지 않고 서로 신뢰성 있는 의사소통을 하게 해준다.

### **TCP/IP가 제공하는 것**
- 오류 없는 데이터 전송
- 순서에 맞는 전달 (TCP/IP의 데이터는 언제나 보낸 순서대로 도착한다.)
- 조각나지 않는 데이터 스트림(언제는 어떤 크기로든 보낼 수 있다.)

## 1.7 프로토콜 버전

### **HTTP/0.9**
- 1991년의 HTTP 프로토타입은 HTTP/0.9로 알려져있다.  
- 이 프로토콜은 심각한 디자인 결함이 다수 있고 구식 클라이언트하고만 사용이 가능하다.

### **HTTP/1.0**
- 1.0 버전은 처음으로 널리 쓰이기 시작한 HTTP 버전이다.
- 버전 번호, HTTP 헤더, 추가 메서드, 멀티미디어 객체 처리를 추가했다.
- HTTP/1.0은 시각적으로 매력적인 웹페이지와 상호작용하는 폼을 실현했고 이는 월드와이드 웹을 대세로 만들었다.
- 그렇지만 결코 잘 정의된 명세가 아니다.

### **HTTP/1.0+**
- keep-alive 커넥션, 가상 호스팅, 프락시 연결 등 많은 기능을 공식적이진 않지만 사실상의 표준으로 HTTP에 추가되었다.
- 이 규격 외의 확장된 HTTP 버전을 흔히 HTTP/1.0+라고 부른다.

### **HTTP/1.1**
- HTTP의 설계의 구조적 결함을 교정하고 성능을 최적화 그리고 잘못된 기능 제거에 집중한 버전
- HTTP/1.1은 더 복잡해진 웹 애플리케이션과 배포를 지원한다. 

### **HTTP/2.0**
- HTTP/2.0은 HTTP/1.1 성능 문제를 개선하기 위해 구글의 SPDY 프로토콜을 기반으로 설계가 진행 중인 프로토콜




## 1.8 웹의 구성요소
### **프락시**
- 클라이언트와 서버 사이에 위치한 HTTP 중개자
- 프락시는 클라이언트와 서버 사이에 위치하여 클라이언트의 모든 HTTP 요청을 받아 서버에 전달
- 프락시는 주로 보안을 위해 사용된다. 웹 트래픽 흐름 속에서 신뢰할 만한 중개자 역할을 하거나 요청과 응답을 필터링 한다.

### **캐시**
- 많이 찾는 웹페이지를 클라이언트 가까이에 보관하는 HTTP 창고
- 웹캐시와 캐시 프락시는 자신을 거쳐 가는 문서들 중 자주 찾는 것의 사본을 저장해두는 특별한 종류의 HTTP 프락시 서버
- 클라이언트는 멀리 떨어진 웹 서버보다 근처의 캐시에서 훨신 더 빨리 문서를 다운받을 수 있다.

### **게이트웨이**
- 다른 애플리케이션과 연결된 특별한 웹 서버
- 게이트웨이는 주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용된다.
- 게이트웨이는 언제나 스스로가 리소스를 갖고 있는 진짜 서버인 것처럼 요청을 다룬다.
- 클라이언트는 자신이 게이트웨이와 통신하고 있는 것을 알아채지 못한다.

### **터널**
- 단순히 HTTP 통신을 전달하기만 하는 특별한 프락시
- 터널은 두 커넥션 사이에서 로우 데이터를 열어보지 않고 그대로 전달해주는 HTTP 애플리케이션
- 터널은 주로 암호회된 SSL 트래픽을 HTTP 커넥션으로 전송함으로써 웹 트리팩만 허용하는 사내 방화벽을 통과시키는 것이 있다.

### **에이전트**
- 에이전트는 사용자를 위해 HTTP 요청을 만들어주는 클라이언트 프로그램이다. 
- 웹 요청을 만드는 애플리케이션은 뭐든 HTTP 에이전트다. 우리에게 가장 익숙한 것은 웹브라우저가 있다.

