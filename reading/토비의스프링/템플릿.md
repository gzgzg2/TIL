# 템플릿
> 템플릿이란 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며
> 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로
> 독립시켜서 효과적으로 활용할 수 있도록 하는 방법
> 
> 간단하게 말하면 변하지 않는 부분과 변하는 부분을 분리하는 것

```text
[SOLID의 개방 폐쇄 원칙 (OCP)]
개방 폐쇄 원칙이란 어떤 부분은 변경을 통해 그 기능이 다양해지고 확장하려는 성질이 있고,
어떤 부분은 고정되어 있고 변하지 않으려는 성질이 있음을 의미한다

변화의 특성이 다른 부분을 구분해주고, 각각 다른 목적과 다른 이유에 의해 다른 시점에 독립적으로
변경될 수 있는 효율적인 구조를 만들어주는 것이 개방 폐쇄 원칙이다.
```

### 템플릿 메소드 패턴
템플릿 메소드 패턴은 상속을 통해 기능을 확장해서 사용하는 패턴. 변하지 않는 부분은 슈퍼 클래스에 두고
변하는 부분은 추상 메소드로 정의해둔다음 서브클래스에서 오버라이드하여 새롭게 정의해서 쓰도록 하는 것

템플릿 메소드 패턴은 장점도 있지만 개인적으로 생각하는 큰 단점은 책에서 설명하듯, 서브클래스들이 이미 클래스
레벌에서 컴파일 시점에 관계가 결정되어 있는 것이다. 이 경우 그 관계에 대한 유연성이 떨어져 버린다.

### 전략 패턴
전략패턴은 오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만
의존하도록 만든다. 전략패턴은 OCP 관점에 보면 확장에 해당하는 변하는 부분을 별도의
클래스로 만들어 추상화된 인터페이스를 통해 위임하는 방식이다. 

전략 패턴에 따르면 Context가 어떤 전략을 사용할 것인가는 Context를 사용하는 앞단의 Client가 
결정하는 것이 일반적이다. Client가 구체적인 전략의 하나를 선택하고 오브젝트로 만들어서 Context에 전달하는 것이다.

<img width="661" alt="image" src="./img/stategyPattern.png">

- Client
  - 전략을 생성하거나 선택하고 Context에 제공하는 역할
  - Context를 호출하는 책임을 지고 있음

- Context
  - 변하지 않는 부분을 분리한 클래스나 메소드
  - Client에게 전달받은 전략을 호출하는 책임을 지고 있음 
  - Context는 Strategy의 구현체는 알지 못함

- Strategy 
  - 변하는 부분을 추출하여 추상화한 클래스
  - Context가 전략을 실행하는데 사용하는 방법이 선언되어 있음 (인터페이스의 method)

- ConcreteStrategy
  - 추상화된 전략의 구현체 
  - Context가 사용할 다양한 알고리즘을 구현

```text
마이크로 DI

DI가 매우 작은 단위의 코드와 메소드 사이에서 일어나는 경우를 의미함
DI의 장점을 단순화해서 IoC 컨테이너의 도움 없이 코드 내에서 적용한 경우를 마이크로 DI라고도 한다.
또는 코드에 의한 DI라는 의미로 수동 DI라고 부를 수도 있다.

** DI의 가장 중요한 개념은 제3자의 도움을 통해 두 오브젝트 사이의 유연한 관계가 설정되도록 만든다는 것
때문에 DI를 돕기위한 새로운 역할이 추가되지 않거나 IoC 컨테이너가 사용되지 않더라도 제 3자의 도움을 통해
유연한 관계가 만들어지면 DI가 이뤄지고 있음을 알 수 있다. 
```

### 로컬 클래스
**[ 개인적인 생각 ]**

전략패턴의 단점 (전략이 추가될 때마다 새로운 구현체가 추가되는 문제)를 해결하기 위해 로컬 클래스를 이용할 수 있다.
그런데 로컬 클래스는 개인적으로 단점을 해결하기 위해 좋은 방법이 아닌 것 같다는 느낌이 든다. 

일단 전략패턴은 클래스가 추가되더라도 클라이언트 코드가 간결하기 때문에 읽기 수월하다는 장점이 있었는데
로컬 클래스 같은 경우에는 내부 클래스여서 자신이 선언된 곳의 정보를 가져올 수 있다는 장점과 
클래스 파일이 추가되지 않는다는 장점이 있어도 클라이언트 코드가 너무 더렵혀진다는 느낌이 든다. 
불필요한 내부 클래스 생성이라는 생각도 들었다.

### 익명 내부 클래스
내부 클래스를 생성할 거라면 익명 내부 클래스로 생성하는 방법도 좋은 방법이다.
익명 내부 클래스는 클래스 선언과 오브젝트 생성이 결합된 형태로 만들어지기 때문에 이름을 갖지 않는다.
상속할 클래스나 구현할 인터페이스를 생성자 대신 사용해서 다음과 같은 형태로 만들어서 사용한다.

익명 내부 클래스는 클래스를 재사용할 필요가 없고 구현한 인터페이스 타입으로만 사용할 경우에 유용하다.

- 예시
  - new 인터페이스 이름() {클래스 본문};

### 의존관계 주입
의존관계 주입 개념을 충실히 따르면 인터페이스를 사이에 두어 런타임 시에 의존할 오브젝트와의 관계를
다이나믹하게 주입하는 것이 맞다. 따라서 인터페이스를 사용하지 않으면 온전한 DI라고 보기 힘들다. 그러나
스프링읠 DI는 IoC라는 개념을 포괄하기 때문에 객체의 생성과 관계설정 권한을 오브젝트에서 제거하고
외부로 위임했다면 DI의 기본을 따르고 있다고 볼 수 있다.  
