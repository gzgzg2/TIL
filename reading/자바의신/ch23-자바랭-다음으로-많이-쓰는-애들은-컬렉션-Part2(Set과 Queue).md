# 자바랭 다음으로 많이 쓰는 애들은 컬렉션 - Part2(Set과 Queue)


## Set
> Set은 순서에 상관없이 어떠한 데이터가 존재하는지 확인하는 용도로 자주 사용된다.  
> Set은 중복된 값을 저장할 수 없다. 이미 Set에 저장된 값을 추가하게될 경우 덮어씌워지게 된다.  
> 중복된 데이터를 확인해야 하는 `Set`에선 equals()와 hashCode() 메소드를 구현하는 부분은 매우 중요하다.


### HashSet
> 순서가 전혀 필요없는 데이터는 해시 테이블에 저장한다. Set중에 가장 성능이 좋다.

**HashSet의 생성자**

| 생성자                                            | 설명                                                        |
|------------------------------------------------|-----------------------------------------------------------|
| HashSet()                                      | 데이터를 저장할 수 있는 16개의 공간과 0.75의 로드 팩터(load factor)를 갖는 객체를 생성한다. |
| HashSet(Collection<? extends E> c)             | 매개 변수로 받은 컬랙션 객체의 데이터를 HashSet에 담는다.                      |
| HashSet(int initialCapacity)                   | 매개 변수로 받은 개수만큼의 데이터 저장 공간과 0.75의 로드 팩터를 갖는 객체를 생성한다.      |
| HashSet(int initialCapacity, float loadFactor) | 첫 매개 변수로 받은 개수만큼의 데이터 저장 공간과 0.75의 로드 팩터를 갖는 객체를 생성한다.    |

**로드팩터란?**
- (데이터개수)/(저장 공간)을 의미한다.
- 데이터의 개수가 로드 팩터보다 커지면 저장 공간의 크기는 증가되고 해시 재정리 작업을 해야한다.
- 해시 재정리 작업이 들어가면 내부 자료구조를 다시 생성하는 단계를 거쳐야하므로 성능에 영향이 발생한다.
- 로드팩터가 크면 저장 공간은 널널해지지만, 값을 찾는 시간이 증가한다.

### TreeSet
> 저장된 데이터에 값에 따라서 정렬되는 셋이다. red-black이라는 트리타입으로 값이 저장된다. HashSet보다 약간 성능이 느리다.


### LinkedHashSet
> 연결된 목록 타입으로 구현된 해시 테이블에 데이터를 저장한다. 저장된 순서에 따라서 값이 정렬된다. 성능이 셋 중에 제일 나쁘다.

## Queue는 왜 필요할까?
- Queue는 LinkedList를 확장한 클래스이다.
- Queue는 FIFO(First In First Out)의 용도로 사용된다.
- WAS에서 요청을 순서대로 처리할 때 Queue와 같은 자료구조를 이용하여 들어온 순서대로 요청을 처리할 수 있다.
- Java6에서는 Deque(Double Ended Queue)도 추가되었다. Deque는 맨 앞에 값을 넣거나 뺼 수 있고, 맨 뒤에서도 값을 넣거나 뺼 수 있다.  